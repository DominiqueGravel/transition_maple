quartz(height = 5, width = 6)#
par(mar=c(5,6,2,1))#
Patches = connected(N=25)#
XY = Patches[[1]]#
ConMat = Patches[[2]]#
#
plot(XY[,1],XY[,2],xlab = "X", ylab = "Y",cex.lab = 1.5, cex.axis = 1.25)#
ConVec = stack(as.data.frame(ConMat))[,1]#
XX = expand.grid(XY[,1],XY[,1])#
YY = expand.grid(XY[,2],XY[,2])#
XX = subset(XX,ConVec==1)#
YY = subset(YY,ConVec==1)#
arrows(x0 = XX[,1],x1=XX[,2],y0 = YY[,1], y1 = YY[,2], length = 0,lwd = 0.1)#
points(XY[,1],XY[,2],pch=21,bg="blue")
quartz(height = 5.5, width = 6)#
par(mar=c(5,6,2,1))#
Patches = connected(N=25)#
XY = Patches[[1]]#
ConMat = Patches[[2]]#
#
plot(XY[,1],XY[,2],xlab = "X", ylab = "Y",cex.lab = 1.5, cex.axis = 1.25)#
ConVec = stack(as.data.frame(ConMat))[,1]#
XX = expand.grid(XY[,1],XY[,1])#
YY = expand.grid(XY[,2],XY[,2])#
XX = subset(XX,ConVec==1)#
YY = subset(YY,ConVec==1)#
arrows(x0 = XX[,1],x1=XX[,2],y0 = YY[,1], y1 = YY[,2], length = 0,lwd = 0.1)#
points(XY[,1],XY[,2],pch=21,bg="blue")
9*15000
9*15000*8
XY = matrix(nc = 2, nr = N)#
#
	# First node coordinate:#
	XY[1,1] = 0#
	XY[1,2] = 0	#
	n = 2
nlevel = length(subset(XY[,1],XY[,1] == n-1))
nlevel
subset(XY[,1],XY[,1] == n-1)
XY
First node coordinate:#
	XY[1,1] = 1#
	XY[1,2] = 0
length(subset(XY[,1],XY[,1] == n-1))
X = rnorm(N, 0, 1)
Y = rexp(N, rate = 1)
plot(X,Y)
Y = runif(N,0,1)
plot(X,Y)
X = runif(N, 0, 1)
Y = runif(N,0,1)
plot(X,Y)
X = sort(runif(N, 0, 1))
Y = runif(N,0,1)
plot(X,Y)
X = sort(runif(N,0,1))#
	Y = runif(N,0,1)
plot(X,Y)
i = 2
which.min(distMat[,i])
X = sort(runif(N,0,1))#
	Y = runif(N,0,1)#
	XY = cbind(X,Y)#
	distMat = as.matrix(dist(XY,method = "euclidean", upper = T, diag = T))	#
	ConMat = matrix(0, nr=N,nc=N)
which.min(distMat[,i])
distMat[,i]
diag(distMat) = 999
which.min(distMat[,i])
distMat[,i]
t=distMat[,i]
t
t=which.min(distMat[,i])
t
t[1]
t[2]
t[2]t*2
t[2]*2
t*2
t*10
X = sort(runif(N,0,1))#
	Y = runif(N,0,1)#
	XY = cbind(X,Y)#
	distMat = as.matrix(dist(XY,method = "euclidean", upper = T, diag = T))	#
	diag(distMat) = 999#
	ConMat = matrix(0, nr=N,nc=N)
nlinks = apply(ConMat,2,sum)
nlinks
0.8*178000
0.8*178000-118000
255/3*2
20*7.42
0.86*8*14
40+84+110+208
35*13.40
469/18.50
40*13.40
536/18.50
11*18.50
11*18.50/13.40
22*35*4*4.3
Xlim = 150#
Ylim = 50#
N = Xlim*Ylim#
X = c(1:Xlim)#
Y = c(1:Ylim)#
XY = expand.grid(X,Y)#
distMat = as.matrix(dist(XY,method = "euclidean", upper = T, diag = T))#
ConMat = matrix(0, nr=N,nc=N)#
ConMat[distMat<1.5] = 1#
diag(ConMat) = 0#
#
S = 2#
nsteps = 1000#
e1 = 0.1#
e2 = 0.1#
amax = 1.1#
cross = 120#
b0 = 1#
a = (amax-b0)/cross#
a0 = amax - a*XY[,1]#
a1 = -0.05#
#
# N: number of cells in the lattice#
# presence: Vector of species presence/absence (0: absence, 1: presence, NxS dimension)#
#
# Initiatization of the metaco, distribute trees at random #
pres1 = matrix(0,nrow = N,nc = S)#
rand = runif(N,0,1)#
pres1[rand<0.5,1] = 1#
pres1[rand>0.5,2] = 1#
rel = matrix(nr = nsteps,nc = 2)#
n=1#
#
quartz(width = 5, height = 5)#
# Loop over all time steps#
for(time in 1:nsteps) {#
	pres0 = pres1#
#
	# Mortality events#
	randMort = runif(N,0,1)#
	pres1[randMort<e1,1] = 0#
	pres1[randMort<e2,2] = 0#
	# Replacement events#
	# Calculate abundance in the neighbourhood#
	ConPop = (ConMat%*%pres0)#
#
	# Calculate the recruitment probability#
	fitness = matrix(0,nr=N,nc=S)#
	fitness[pres0[,1]==1,1] = a0[pres0[,1]==1]#
	fitness[pres0[,1]==0,1] = a0[pres0[,1]==0]+a1	 	#
	fitness[,2] = b0#
	recruitProb = numeric(N)#
	recruitProb = ConPop[,1]*fitness[,1]/apply(ConPop*fitness,1,sum)#
	# Pick a species at random and do replacement#
	randRecruit = runif(N,0,1)#
	pres1[apply(pres1,1,sum)==0 & recruitProb > randRecruit,1] = 1#
	pres1[apply(pres1,1,sum)==0 & recruitProb < randRecruit,2] = 1#
#
	# Record each species relative abundance#
	rel[time,] = apply(pres1,2,sum)/N#
#
	if(n == 10) {#
	z = matrix(nr=Xlim,nc=Ylim)#
	for(x in 1:Xlim) for(y in 1:Ylim) z[x,y] = pres1[XY[,1]==x & XY[,2]==y,1]#
#
	t = layout(matrix(c(1,2),nr=2,nc=1),height=c(1,3))#
	layout.show(t)#
	par(mar=c(0.5,5,1,1))#
#
	sp1 = numeric(Xlim)#
	sp2 = numeric(Xlim)#
	A0 = amax - a*c(1:Xlim)#
	sp1[A0>b0] = 1#
	sp2[b0>(A0+a1)] = 0.99#
#
	plot(c(1:Xlim),sp1,type="l", col = "blue",lwd = 2,ylab="Presence",xaxt = "n",xlab = "")#
	lines(c(1:Xlim),sp2,col = "red", lwd = 2)	#
	REL = tapply(pres1[,1],INDEX = XY[,c(1,2)],sum)/10	#
	for(i in 1:6) points(c(1:Xlim),REL[,i])#
	title(main = paste("Time = ",time,sep = ""))#
#
	par(mar=c(5,5,0.5,1))#
	image(x=c(1:Xlim),y=c(1:Ylim),z=z,col = c("blue","red"),xlab = "X", ylab = "Y")#
	n = 1#
	cat(time,'\n')#
	}#
	else n = n+1#
	cat(time,'\n')#
}#
# nbin = 5#
# Ybin = floor(XY[,2]/nbin)#
# ind = cbind(XY[,1],Ybin)#
#
# REL = matrix(nr = 150*floor(Ylim/nbin),nc=2)#
# n = 1#
# for(i in 1:Xlim) #
	# for(j in 0:(floor(Ylim/nbin)-1)) {#
		# REL[n,1] =i#
		# REL[n,2] = sum(subset(pres1[,1],ind[,1]==i&ind[,2]==j))#
		# n = n+1#
		# }	#
# hist(REL[REL[,1]==100,2]/5)
4*44
eig_J = function(S, C=0.05, a = 1) {#
#
	# Tirage de paramètres au hasard#
	J = matrix(rnorm(S^2,0,a),nr=S,nc=S)#
#
    # Tirage des éléments ij qui sont différents de 0#
    rand = matrix(runif(S^2,0,1),nr=S,nc=S) #
    J[rand>C*2] = 0 #
    # Compétition au long de la diagonale#
    diag(J) = -a#
    # Analyse de valeur propre#
    return(max(as.real(eigen(J)$values)))#
	}#
#
# Effet de la diversité sur la stabilité#
S = rep(c(10:100),25)#
#
# Utilisation de la fonction lapply pour calculer la stabilité pour toutes les valeurs de S#
res = as.numeric(lapply(S,eig_J))#
#
# Calcul de la valeur moyenne pour chaque S#
res_avg = tapply(res,INDEX=S,FUN=mean)#
#
# Illustration des résultats#
quartz()#
par(mar=c(5,6,2,1))#
plot(c(10:100),res_avg, xlab = "Nombre d'espèces", ylab = "Valeur propre maximale", cex.lab = 1.5, cex.axis = 1.25)#
abline (h = 0)
plot(c(10:100),res_avg, xlab = "Nombre d'espèces", ylab = "Valeur propre maximale", cex.lab = 1.5, cex.axis = 1.25, pch = 19, cex = 3)
plot(c(10:100),res_avg, xlab = "Nombre d'espèces", ylab = "Valeur propre maximale", cex.lab = 2.5, cex.axis = 2.25, pch = 19, cex = 3)
abline (h = 0)
abline (h = 0, lwd = 2)
g = function(N0,r,K,nstep) {#
	Nt = N0#
	res = numeric(nstep)#
	res[1]=N0#
	for(i in 2:nstep) {#
		Nt = Nt + r*Nt*(1-Nt/K)#
		res[i] = Nt#
	}#
	return(res)#
}#
#
par(mar=c(6,6,2,1))
par(mar=c(6,6,2,1))#
plot(c(1:20),g(N0=50,r=1.9,K=100,nstep=20),type="l",xlab = "Temps", ylab = "Taille de population",cex.lab = 1.75, cex.axis = 1.5,main="r = 1.9")
plot(c(1:20),g(N0=50,r=2.4,K=100,nstep=20),type="l",xlab = "Temps", ylab = "Taille de population",cex.lab = 1.75, cex.axis = 1.5,main="r = 2.4")
library(deSolve)#
#
#########################
# Définition du modèle mathématique#
model = function(Time, State, Pars) {#
	with(as.list(c(State,Pars)), {#
		dN = r*N*(1-N/K) - a*N*P/(1+b*N)#
		dP = a*N*P/(1+b*N) - m*P 	  #
		list(c(dN,dP))#
	})#
}#
#
#########################
# Définition des paramètres#
r = 1#
K = 0.6#
a = 1#
b = 5#
m = 0.1#
#
# On les rassemble dans un objet appelé pars#
pars = c(r = r, K = K, a = a, b = b, m = m)	#
#
#########################
# Conditions de départ#
N0 = c(N = 1, P = 0.1)#
#
######################## #
# Durée de la simulation#
times = seq(0,250, by = 0.1)  #
#
#########################
# Réalisation de la simulation#
# La première colonne de l'objet out représente le temps et les autres la densité#
out = ode(func=model,y = N0, parms = pars, times = times)#
#########################
# Illustration de la sortie#
par(mar=c(6,6,2,1)) #
plot(out[,1],out[,2],type="l",xlab = "Temps",ylab = "Densité",cex.lab = 1.75, cex.axis = 1.5,ylim=range(out[,2:3]))  #
lines(out[,1],out[,3],col = "red")
plot(out[,2],out[,3], type = "l")
plot(out[,2],out[,3], type = "l",cex.axis =2.5, cex.lab = 2.5, xlab = "Proie", ylab = "Predateur", lwd = 2)
Illustration du R*#
####
#
# Paramètres#
a = 1#
b = 2.5#
Nstar = m/(a-m*b)#
#
# Valeurs de N#
N = seq(0.2,1,0.01)#
#
# Figure#
par(mar=c(6,6,2,1))#
plot(N,a*N/(1+b*N),type="l",lwd = 2, col = "red", xlab = "Disponibilité de N", ylab = "Taux de changement",cex.lab = 1.5,cex.axis=1.25)#
abline(h = m, lwd = 2)#
legend("bottomright",legend = c("Croissance","Mortalité"), lwd = 2, col = c("red","black"),bty="n",cex=1.5)#
abline(v = Nstar,lty=3)#
text(x=0.44,y=0.28,"N*",cex=1.5)
On utilise une librairie pour faire l'intégration numérique d'équations différentielles#
library(deSolve)#
#
# Définition du modèle mathématique#
model = function(Time, State, Pars) {#
with(as.list(c(State,Pars)), {#
   	  dN = I - e*N - a*N*P/(1+b*N) #
  	  dP = a*N*P/(1+b*N)  - m*P#
	  return(list(c(dN,dP)))#
	})#
}#
#
# Paramètres #
pars = list(I = .2, e = 0.1, a = 1, b = 2.5, m = 0.2)#
#
# Conditions de départ#
T0 = c(N = 1, P = 0.001)#
# Durée de la simulation#
times = seq(0,100, by = 0.1)  #
#
# Réalisation de la simulation#
out = ode(func=model,y = T0, parms = pars, times = times)#
# Illustration des résultats#
par(mar=c(6,6,2,1))#
plot(out[,1],out[,2],type="l",xlab = "Temps", ylab = "Densité",cex.lab = 1.5, cex.axis = 1.25, main = "",ylim=range(out[,2:3]),lwd=2)#
lines(out[,1],out[,3],col = "red",lwd=2)#
abline(h = Nstar,lty=3)#
legend("topright",legend = c("P","N"), lwd = 2, col = c("red","black"),bty="n",cex=1.5)
Définition du modèle mathématique#
model = function(Time, State, Pars) {#
with(as.list(c(State,Pars)), {#
		dR = r*R*(1-R/K) - a1*R*C1/(1+b1*R)#
		dC1 = a1*R*C1/(1+b1*R) - m1*C1 - a2*C1*C2/(1+b2*C1)#
		dC2 = a2*C1*C2/(1+b2*C1) - m2*C2   #
		list(c(dR,dC1,dC2))#
	})#
}#
#########################
# Définition des paramètres#
r = 1#
K = 0.6#
a1 = 1#
b1 = 5#
m1 = 0.1#
a2 = 1#
b2 = 5#
m2 = 0.1#
#
# On les rassemble dans un objet appelé pars#
pars = c(r = r, K = K, a1 = a1, b1 = b1, m1 = m1, a2 = a2, b2 = b2, m2 = m2)	#
#
#########################
# Conditions de départ#
N0 = c(R = 1, C1 = 0.1, C2 = 0.01)#
#
######################## #
# Durée de la simulation#
times = seq(0,1000, by = 0.1)  #
#
#########################
# Réalisation de la simulation#
# La première colonne de l'objet out représente le temps et les autres la densité#
out = ode(func=model,y = N0, parms = pars, times = times)#
#########################
# Illustration de la sortie#
par(mar=c(6,6,2,1)) #
plot(out[,1],out[,2],type="l",xlab = "Temps",ylab = "Densité",cex.lab = 1.75, cex.axis = 1.5,ylim=range(out[,2:4]))  #
lines(out[,1],out[,3],col = "red")  #
lines(out[,1],out[,4],col = "blue")
plot(out[,2],out[,3], type = "l",cex.axis =2.5, cex.lab = 2.5, xlab = "Proie", ylab = "Predateur", lwd = 2)
Durée de la simulation#
times = seq(0,2500, by = 0.1)  #
#
#########################
# Réalisation de la simulation#
# La première colonne de l'objet out représente le temps et les autres la densité#
out = ode(func=model,y = N0, parms = pars, times = times)
Illustration de la sortie#
par(mar=c(6,6,2,1)) #
plot(out[,1],out[,2],type="l",xlab = "Temps",ylab = "Densité",cex.lab = 1.75, cex.axis = 1.5,ylim=range(out[,2:4]))  #
lines(out[,1],out[,3],col = "red")  #
lines(out[,1],out[,4],col = "blue")
plot(out[500:2500,2],out[500:2500,3], type = "l",cex.axis =2.5, cex.lab = 2.5, xlab = "Proie", ylab = "Predateur", lwd = 2)
plot(out[,2],out[,3], type = "l",cex.axis =2.5, cex.lab = 2.5, xlab = "Proie", ylab = "Predateur", lwd = 2)
library(rootSolve)#
#
# Étape 1: le modèle#
model = function(t,y,pars) {#
	with(as.list(c(y,pars)), {#
		dN = r*N*(1-N/K) - a*N*P/(1+b*N)#
		dP = a*N*P/(1+b*N) - d*P 		#
		list(c(dN,dP))#
		})#
	}#
#
# Paramètres#
pars = c(r = 1, K = 0.7, a = 1, b = 5, d = 0.1)	#
#
# Conditions de départ#
y = c(N = 0.1, P = 1.1)#
# Étape 2: obtention de l'équilibre à l'aide de la fonction stode (iterative steady state)#
eq = stode(y=y, func=model, parms=pars, pos=TRUE)[[1]]#
#
# Étape 3: calcul de la jacobienne à l'aide de la fonction jacobian.full#
J = jacobian.full(y=eq,func=model,parms=pars)#
#
# Étape 4: analyse de stabilité locale#
library(MASS)#
#
eigen(J)$values#
as.real(eigen(J)$values)
library(deSolve)#
#
# Vecteur des valeurs de K#
Ks = seq(0.5,1,0.01)#
#
# Vecteur pour enregistrer les résultats#
res = numeric(length(Ks))#
#
# Boucle pour calculer toutes les valeurs propres pour chaque K#
for(i in 1:length(Ks)) {	#
	pars = c(r = 1, K = Ks[i], a = 1, b = 5, d = 0.1)#
	eq = stode(y=eq, func=model, parms=pars, pos=TRUE)[[1]]#
	J = jacobian.full(y=eq,func=model,parms=pars)#
	res[i] = max(as.real(eigen(J)$values))#
	}#
#
# Illustration des résultats#
quartz(width = 12, height = 4)#
#windows(width = 12, height = 4)#
par(mar = c(5,6,2,1),mfcol=c(1,3))#
plot(Ks,res, type = "l", xlab = "Fertilité", ylab = "Valeur propre maximale", cex.axis = 1.25, cex.lab = 1.5)#
abline(h = 0, lty = 3)
plot(Ks,res, type = "l", xlab = "Fertilité", ylab = "Valeur propre maximale", cex.axis = 1.25, cex.lab = 1.5)
Xlim = 150#
Ylim = 20#
N = Xlim*Ylim#
X = c(1:Xlim)#
Y = c(1:Ylim)#
XY = expand.grid(X,Y)#
distMat = as.matrix(dist(XY,method = "euclidean", upper = T, diag = T))#
ConMat = matrix(0, nr=N,nc=N)#
ConMat[distMat<1.5] = 1#
diag(ConMat) = 0#
#
S = 2#
nsteps = 10000#
e1 = 0.1#
e2 = 0.1#
amax = 1.1#
cross = 120#
b0 = 1#
a = (amax-b0)/cross#
a0 = amax - a*XY[,1]#
a1 = -0.05#
#
# N: number of cells in the lattice#
# presence: Vector of species presence/absence (0: absence, 1: presence, NxS dimension)#
#
# Initiatization of the metaco, distribute trees at random #
pres1 = matrix(0,nrow = N,nc = S)#
rand = runif(N,0,1)#
pres1[rand<0.5,1] = 1#
pres1[rand>0.5,2] = 1#
rel = matrix(nr = nsteps,nc = 2)#
n=1#
#
quartz(width = 5, height = 5)#
# Loop over all time steps#
for(time in 1:nsteps) {#
	pres0 = pres1#
#
	# Mortality events#
	randMort = runif(N,0,1)#
	pres1[randMort<e1,1] = 0#
	pres1[randMort<e2,2] = 0#
	# Replacement events#
	# Calculate abundance in the neighbourhood#
	ConPop = (ConMat%*%pres0)#
#
	# Calculate the recruitment probability#
	fitness = matrix(0,nr=N,nc=S)#
	fitness[pres0[,1]==1,1] = a0[pres0[,1]==1]#
	fitness[pres0[,1]==0,1] = a0[pres0[,1]==0]+a1	 	#
	fitness[,2] = b0#
	recruitProb = numeric(N)#
	recruitProb = ConPop[,1]*fitness[,1]/apply(ConPop*fitness,1,sum)#
	# Pick a species at random and do replacement#
	randRecruit = runif(N,0,1)#
	pres1[apply(pres1,1,sum)==0 & recruitProb > randRecruit,1] = 1#
	pres1[apply(pres1,1,sum)==0 & recruitProb < randRecruit,2] = 1#
#
	# Record each species relative abundance#
	rel[time,] = apply(pres1,2,sum)/N#
#
	if(n == 10) {#
	z = matrix(nr=Xlim,nc=Ylim)#
	for(x in 1:Xlim) for(y in 1:Ylim) z[x,y] = pres1[XY[,1]==x & XY[,2]==y,1]#
#
	t = layout(matrix(c(1,2),nr=2,nc=1),height=c(1,3))#
	layout.show(t)#
	par(mar=c(0.5,5,1,1))#
#
	sp1 = numeric(Xlim)#
	sp2 = numeric(Xlim)#
	A0 = amax - a*c(1:Xlim)#
	sp1[A0>b0] = 1#
	sp2[b0>(A0+a1)] = 0.99#
#
	plot(c(1:Xlim),sp1,type="l", col = "blue",lwd = 2,ylab="Presence",xaxt = "n",xlab = "")#
	lines(c(1:Xlim),sp2,col = "red", lwd = 2)	#
	REL = tapply(pres1[,1],INDEX = XY[,c(1,2)],sum)/10	#
	for(i in 1:6) points(c(1:Xlim),REL[,i])#
	title(main = paste("Time = ",time,sep = ""))#
#
	par(mar=c(5,5,0.5,1))#
	image(x=c(1:Xlim),y=c(1:Ylim),z=z,col = c("blue","red"),xlab = "X", ylab = "Y")#
	n = 1#
	cat(time,'\n')#
	}#
	else n = n+1#
	cat(time,'\n')#
}#
# nbin = 5#
# Ybin = floor(XY[,2]/nbin)#
# ind = cbind(XY[,1],Ybin)#
#
# REL = matrix(nr = 150*floor(Ylim/nbin),nc=2)#
# n = 1#
# for(i in 1:Xlim) #
	# for(j in 0:(floor(Ylim/nbin)-1)) {#
		# REL[n,1] =i#
		# REL[n,2] = sum(subset(pres1[,1],ind[,1]==i&ind[,2]==j))#
		# n = n+1#
		# }	#
# hist(REL[REL[,1]==100,2]/5)
87.92+65.53+96
here is code to simulate environmental gradients that alter both the k's and the alphas#
#
#methods:#
#create an environmental gradient from 0 to 1#
#
x<-1:100/100#
#
#on this gradient make K1, K2 and alpha to be functions of x#
#for each of these terms you need to specify a slope (m) and intercept (b)#
#K1=1*x+0 (model rescaled for simplicity, by setting m1=1, m20)#
#K2=m2*x+b2#
#alpha12=m3*x+b3#
# parameters to control K2 and alpha#
m2<- -1#
b2<-  1#
m3<- -5#
b3<- 4#
par(mfrow=c(2,1))#
plot(x, x, type="l", col="black", ylab="K's and alphas", xlim=c(0,1.5), main="plot of environmental gradient")#
points(x, m2*x+b2, type="l", col="blue")#
points(x, m3*x+b3, type="l", col="green")#
legend(1.1, 0.95, c("K1", "K2", "alpha"), col = c("black","blue","green"),#
       text.col = "black", lty = c(1, 1, 1), pch = c(-1, -1, -1),#
       merge = TRUE, bg = 'gray90')#
#make plot of outcomes of itneractions    #
a<-10:175/100#
#
plot(a, a, log="y", type="l", ylim=c(0.1,10), ylab="K1/K2", xlab="alpha", main="plot of outcomes of competition")#
points(a,1/a, type="l")#
text(0.5,1, "stable")#
text(1.5,1, "unstable")#
text(1, 7, "1 wins")#
text(1, 0.3, "2 wins")#
#
#overlay environmental gradient#
ratioK1K2<-x/(m2*x+b2)#
alpha<- m3*x+b3#
points(alpha, ratioK1K2, type="l", col="grey", lwd="4")
plot(a, a, log="y", type="l", ylim=c(0.1,10), ylab="K1/K2", xlab="alpha", main="plot of outcomes of competition")#
points(a,1/a, type="l")#
text(0.5,1, "stable")#
text(1.5,1, "unstable")#
text(1, 7, "1 wins")#
text(1, 0.3, "2 wins")
ratioK1K2<-x/(m2*x+b2)#
alpha<- m3*x+b3#
points(alpha, ratioK1K2, type="l", col="grey", lwd="4")
library(rootSolve)#
#
#############################################################################
##
# Model 1: direct interactions between two species#
# Effect on the extinction coefficient#
# #
#############################################################################
#
model1 = function(Time, State, Pars) {#
	with(as.list(c(State,Pars)), {#
		dp1 =  c1*(p1+p12)*(1-p1-p12) + e2*p12 + e12*p12 - e1*p1 - c2*(p2+p12)*p1#
		dp2 =  c2*(p2+p12)*(1-p2-p12) + e1*p12 + e21*p12 - e2*p2 - c1*(p1+p12)*p2#
		dp12 = c1*(p1+p12)*p2 + c2*(p2+p12)*p1 - (e1+e2+e12+e21)*p12#
		list(c(dp1,dp2,dp12))#
	})#
}#
runmodel1 = function(c1,c2,e1,e2,e12,e21) {#
	y0 = c(p1 = 1, p2 = 1, p12 = 1)#
	pars = c(c1 = c1, c2 = c2, e1 = e1, e2 = e2, e12 = e12, e21 = e21)#
	results = steady(func=model1,y = y0, parms = pars, time=c(0,100), positive = TRUE)$y	#
	return(results)		#
}#
#
ei = seq(-0.2,0.2,0.01)#
#
res1 = matrix(nr = length(ei)^2,nc=3)#
n = 1#
for(i in 1:length(ei)) {#
	for(j in 1:length(ei)) {#
		res1[n,] = runmodel1(c1=0.5,c2=0.5,e1=0.3,e2=0.3,e12=ei[i],e21=ei[j])#
		n = n+1#
		cat(n,'\n')#
	}#
}#
#
grid = expand.grid(x = -ei, y = -ei)#
grid$z = res1[,3]/apply(res1,1,sum)#
#
quartz()#
plot.new()#
levelplot(z~x*y,grid,xlab = "Interaction strenght species 1", ylab = "Interaction strength species 2", colorkey = TRUE)#
mtext(side = 3, line = 2.5, cex = 1.5, text = "Two species direct interactions")
library(lattice)
levelplot(z~x*y,grid,xlab = "Interaction strenght species 1", ylab = "Interaction strength species 2", colorkey = TRUE)
mtext(side = 3, line = 2.5, cex = 1.5, text = "Two species direct interactions")
model2 = function(Time, State, Pars) {#
	with(as.list(c(State,Pars)), {#
	dp1 = c1*(p1+p12+p123)*(1-p1-p12-p123) + e2*p12 - c2*(p12+p123)*p1 - e1*p1 + e32*p123; #
	dp12 = c2*(p12+p123)*p1 + e3*p123  - e2*p12 - e21*p12 - c3*p123*p12 ; #
	dp123 = c3*p123*p12 - e3*p123 - e32*p123 - e21*p123;#
	list(c(dp1,dp12,dp123))#
	})#
}#
runmodel2 = function(c1,c2,c3,e1,e2,e3,e21,e32) {#
	y0 = c(p1 = 0, p12 = 0, p123 = 1)#
	pars = c(c1 = c1, c2 = c2, c3 = c3, e1 = e1, e2 = e2,e3 = e3, e21 = e21, e32 = e32)#
	results = runsteady(func=model2,y = y0, parms = pars, times=c(0,100))$y	#
	return(results)		#
}#
e21 = seq(0,0.4,0.01)#
e32 = seq(0,0.4,0.01)#
#
res2 = matrix(nr = length(e21)*length(e32),nc=3)#
n = 1#
for(i in 1:length(e21)) {#
	for(j in 1:length(e32)) {#
		res2[n,] = runmodel2(c1=1,c2=1, c3=1, e1=0.2, e2=0.2, e3=0.2, e21 = e21[i], e32 = e32[j])#
		n = n+1#
		cat(n,'\n')#
	}#
}#
#
grid = expand.grid(x = e21, y = e32)#
grid$z = res2[,2]#
quartz()#
plot.new()#
levelplot(z~x*y,grid,xlab = "Herbivore effect on plant", ylab = "Carnivore effect on herbivore", colorkey = TRUE)#
mtext(side = 3, line = 2.5, cex = 1.5, text = "Linear food chain")
b1 = 1#
b2 = 1#
a11 = 1#
a22 = 1#
#
pLV = function(a12,a21) {#
	invj12 =  a12/(a11*b2 - a21*b1)#
	invj21 = -a21/(a12*b2 - a22*b1) #
	return(c(invj12,invj21))#
}#
a12 = seq(-0.9,0.9,0.01)#
a21 = seq(-0.9,0.9,0.01)#
#
resLV = matrix(nr = length(a12)*length(a21),nc=2)#
n = 1#
#
for(i in 1:length(a12)) {#
	for(j in 1:length(a21)) {#
		resLV[n,] = pLV(a12=a12[i],a21=a21[j])#
		n = n+1#
		cat(n,'\n')#
	}#
}#
#
grid = expand.grid(x = a12, y = a21)#
grid$z = resLV[,2]#
quartz()#
plot.new()#
levelplot(z~x*y,grid,xlab = "Species 2 effect on species 1", ylab = "Species 1 effect on species 2", colorkey = TRUE)#
mtext(side = 3, line = 2.5, cex = 1.5, text = "Two species Lotka-Volterra")
SIMPLIFIED MODEL WHERE THERE IS NO POST-COLONIZATION MIXING (PRE-EMPTIVE COMPETTION)#
plot_iso = function(e,sD,sC) {#
#
	aC = seq(0.01,1,0.001)#
#
	aD_crit_D = (aC*(e + sC + sD))/(e + sD + sC*(1 - aC + e))#
	aD_crit_C = aC*(e + sC + sD + e*sD)/(e + sC + sD*(1 + aC))#
#
	par(mar = c(5,6,2,1))#
	plot(aC,aD_crit_D,type = "l", , ylab = "aD",log = "xy",cex.lab = 1.5,cex.axis = 1.25,ylim = c(0.01,1))#
	lines(aC,aD_crit_C,col = "red")#
	abline(v = e,lty = 3)#
	abline(h = e,lty = 3)	#
	}#
#
plot_iso(e = 100^-1, sD = 20^-1, sC = 20^-1)
SECOND CASE: D --> M AND C --> M ARE POSSIBLE#
model = function(Time, State, Pars) {#
	with(as.list(c(State,Pars)), {#
		dCdt = aC*(C+M)*(1-aD*(D+M))*(1-C-D-M) + sC*M - bD*(D+M)*C - e*C#
		dDdt = aD*(D+M)*(1-aC*(C+M))*(1-C-D-M) + sD*M - bC*(C+M)*D - e*D#
		dMdt = aC*(C+M)*aD*(D+M)*(1-C-D-M) + bC*(C+M) + bD*(D+M) - sC*M - sD*M - e*M	  #
		list(c(dCdt,dDdt,dMdt))#
	})#
}#
#
runmodel = function(e,aC,aD,sD,sC,bC,bD) {#
	pars = c(e=e,aC=aC,aD=aD,sD=sD,sC=sC,bC=bC,bD=bD)#
	N1 = c(C=1-e/aC,D=1000^-1,M=0)	#
	N2 = c(C=1000^-1,D=1-e/aD,M=0)	#
	eq1 = runsteady(y = N1, func = model, parms = pars)[[1]]#
	eq2 = runsteady(y = N2, func = model, parms = pars)[[1]]#
	return(c(eq1,eq2))#
}
b = 10^seq(-5,-1,0.1)#
RES = matrix(nr = length(b), nc = 6)#
for(i in 1:length(b)) {RES[i,]=runmodel(e=0.01,aC=0.49,aD=0.51,sD=50^-1,sC=50^-1,bC=b[i],bD=b[i])}#
b = subset(b,RES[,1]<1 & RES[,3]<1)#
RES = subset(RES,RES[,1]<1& RES[,3]<1)#
#
dev.new(width = 8, height = 3.5)#
par(mar = c(5,6,2,1),mfcol = c(1,2))#
plot(b,RES[,1],type = "l",ylim=c(0,1),log = "x",cex.lab = 1.25,cex.axis = 1.25,xlab = "Hetero sp.-replacement", ylab = "Occupancy")#
lines(b,RES[,2],col = "darkred")#
lines(b,RES[,3],col = "darkblue")#
title(main = "D - resident")#
#
par(mar = c(5,6,2,1))#
plot(b,RES[,4],type = "l",ylim=c(0,1),log = "x",cex.lab = 1.25,cex.axis = 1.25,xlab = "Hetero sp.-replacement", ylab = "Occupancy")#
lines(b,RES[,5],col = "darkred")#
lines(b,RES[,6],col = "darkblue")#
title(main = "C - resident")
library(rootSolve)#
library(deSolve)#
runmodel = function(e,aC,aD,sD,sC,bC,bD) {#
	pars = c(e=e,aC=aC,aD=aD,sD=sD,sC=sC,bC=bC,bD=bD)#
	N1 = c(C=1-e/aC,D=1000^-1,M=0)	#
	N2 = c(C=1000^-1,D=1-e/aD,M=0)	#
	eq1 = runsteady(y = N1, func = model, parms = pars)[[1]]#
	eq2 = runsteady(y = N2, func = model, parms = pars)[[1]]#
	return(c(eq1,eq2))#
}#
#
#runmodel(e=0.01,aC=0.5,aD=0.4,sD=50^-1,sC=50^-1,bC=0.0000,bD=0.00000)	#
b = 10^seq(-5,-1,0.1)#
RES = matrix(nr = length(b), nc = 6)#
for(i in 1:length(b)) {RES[i,]=runmodel(e=0.01,aC=0.49,aD=0.51,sD=50^-1,sC=50^-1,bC=b[i],bD=b[i])}#
b = subset(b,RES[,1]<1 & RES[,3]<1)#
RES = subset(RES,RES[,1]<1& RES[,3]<1)#
#
dev.new(width = 8, height = 3.5)#
par(mar = c(5,6,2,1),mfcol = c(1,2))#
plot(b,RES[,1],type = "l",ylim=c(0,1),log = "x",cex.lab = 1.25,cex.axis = 1.25,xlab = "Hetero sp.-replacement", ylab = "Occupancy")#
lines(b,RES[,2],col = "darkred")#
lines(b,RES[,3],col = "darkblue")#
title(main = "D - resident")#
#
par(mar = c(5,6,2,1))#
plot(b,RES[,4],type = "l",ylim=c(0,1),log = "x",cex.lab = 1.25,cex.axis = 1.25,xlab = "Hetero sp.-replacement", ylab = "Occupancy")#
lines(b,RES[,5],col = "darkred")#
lines(b,RES[,6],col = "darkblue")#
title(main = "C - resident")
dev.new*()
dev.new()
plot(b,res[,1],type = "l")
plot(b,RES[,1],type = "l")
plot(b,RES[,1],type = "l",log = "x")
lines(b,RES[,4])
plot(b,RES[,1],type = "l",log = "x",ylim = c(0,1))
lines(b,RES[,4])
dev.new(width = 4, height = 3.5)#
par(mar = c(5,6,2,1))	#
 plot(b,RES[,1],type = "l",log = "x",ylim = c(0,1),cex.lab = 1.25,cex.axis = 1.25,xlab = "Hetero sp.-replacement", ylab = "Occupancy")#
 lines(b,RES[,4])
dev.new(width = 5, height = 3.5)#
par(mar = c(5,6,2,1))	#
 plot(b,RES[,1],type = "l",log = "x",ylim = c(0,1),cex.lab = 1.25,cex.axis = 1.25,xlab = "Hetero sp.-replacement", ylab = "Occupancy")#
 lines(b,RES[,4])
Complexity-stability relationship in random ecosystems#
###################################################################
###################################################################
#
eig_J = function(S, C=0.05, a = 1) {#
#
	# Draw random interaction coefficients#
	J = matrix(rnorm(S^2,0,a),nr=S,nc=S)#
#
    # Keep only a fraction C of the links#
    rand = matrix(runif(S^2,0,1),nr=S,nc=S) #
    J[rand>C] = 0 #
    # Set density-dependence along the diagonal#
    diag(J) = -a#
    # Get the largest eigen value#
    return(max(as.real(eigen(J)$values)))#
	}#
#
# Effect of diversity on stability, loop from 10 to 100 species#
S = rep(c(10:100),25)#
#
# Apply the function eig_J for all values of S#
res = as.numeric(lapply(S,eig_J))#
#
# Compute the average eigeinvalue across the 25 replicates for each diversity#
res_avg = tapply(res,INDEX=S,FUN=mean)#
#
# Illustrate the results#
dev.new()#
par(mar=c(5,6,2,1))#
plot(c(10:100),res_avg, xlab = "Species richness", ylab = "Largest eigenvalue", cex.lab = 1.5, cex.axis = 1.25)#
abline (h = 0)
plot(c(10:100),res_avg, xlab = "Species richness", ylab = "Largest eigenvalue", cex.lab = 1.5, cex.axis = 1.25)
plot(c(10:100),res_avg, xlab = "Species richness", ylab = "Largest eigenvalue", cex.lab = 1.5, cex.axis = 1.25,cex=2)
abline (h = 0)
plot(c(10:100),res_avg, xlab = "Species richness", ylab = "Largest eigenvalue", cex.lab = 1.5, cex.axis = 1.25,cex=2,pch=19)
abline (h = 0)
X1 = rnorm(1000,10,1)#
X2 = rnomr(1000,10,1)
X2 = rnorm(1000,10,1)
ES = log(X1/X2)
X1 = rnorm(1000,10,1)
X2 = rnorm(1000,10,1)
log(X1/X2)
mean(log(X1/X2))
log(mean(X1)/mean(X2))
log(mean(X1/X2))
X1 = rnorm(1000,10,1)#
X2 = rnorm(1000,10,1)#
#
mean(log(X1/X2))#
log(mean(X1)/mean(X2))#
log(mean(X1/X2))
163/2.2
(163/2.2/1.76)^2
74/1.76
74/176
74/1.76^2
832+350+127+2442
2442/40
3*3*2*0.52
S = seq(2,100,1)#
temp = S/(S-1)#
plot(S,temp)
S = seq(2,100,1)#
A = 100#
B = 1#
#
res = S*A/(A*(S-1) + B)#
#
plot(S, res, type = "l")
S = seq(2,100,1)#
A = 1#
B = 100#
#
res = S*A/(A*(S-1) + B)#
#
plot(S, res, type = "l")
S = seq(2,100,1)#
A = 10#
B = 10#
#
res = S*A/(A*(S-1) + B)#
#
plot(S, res, type = "l")
S = seq(2,100,1)#
A = 10#
B = 9#
#
res = S*A/(A*(S-1) + B)#
#
plot(S, res, type = "l")
362.75*329.18
362.75*329.18/10000
50/8
2500/8
2500/8/6
6*55
45*6
% On illustre les résultats#
eq = 0.1#
aC = seq(0.101, 1,0.001)#
bD = 0#
bC = 0#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)#
#
plot(aC,aD_D,type = "l")#
lines(aC,aD_C)
# On illustre les résultats#
e = 0.1#
aC = seq(0.101, 1,0.001)#
bD = 0#
bC = 0#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)#
#
plot(aC,aD_D,type = "l")#
lines(aC,aD_C)#
#
bD = 0.1#
bC = 0.1#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)#
lines(aC,aD_C,col = "darkred")#
lines(aC,aD_D,col = "darkred")
# On illustre les résultats#
e = 0.1#
aC = seq(0.101, 1,0.001)#
bD = 0#
bC = 0#
sC = 0.1#
sD = 0.1#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)#
#
plot(aC,aD_D,type = "l")#
lines(aC,aD_C)#
#
bD = 0.1#
bC = 0.1#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)#
lines(aC,aD_C,col = "darkred")#
lines(aC,aD_D,col = "darkred")
range(aD_D)
range(aD_C)
plot(aC,aD_D,type = "l")
plot(aC,aD_C,type = "l")
plot(aC,aD_C,type = "l",ylim = c(0,10))
lines(aC,aD_D)
plot(aC,aD_C,type = "l",ylim = c(0.01,10),log = "y")
lines(aC,aD_D)
plot(aC,aD_C,type = "l",ylim = c(0.01,10),log = "xy")
# On illustre les résultats#
e = 0.1#
aC = seq(0.101, 10,0.001)#
bD = 0#
bC = 0#
sC = 0.1#
sD = 0.1#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)
plot(aC,aD_D,type = "l",ylim = c(0.01,10),xlim = c(0.01,10))#
lines(aC,aD_C)
# On illustre les résultats#
e = 0.1#
aC = seq(0.101, 10,0.001)#
bD = 0#
bC = 0#
sC = 0.1#
sD = 0.1#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)
plot(aC,aD_D,type = "l",ylim = c(0.01,10),xlim = c(0.01,10))#
lines(aC,aD_C)
plot(aC,aD_D,type = "l",ylim = c(0.01,10),xlim = c(0.01,10),log = "xy")#
lines(aC,aD_C)
bD = 0.1#
bC = 0.1#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)#
lines(aC,aD_C,col = "darkred")#
lines(aC,aD_D,col = "darkred")
# On illustre les résultats#
e = 0.1#
aC = seq(0.101, 10,0.001)#
bD = 0#
bC = 0#
sC = 0.1#
sD = 0.1#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)#
#
plot(aC,aD_D,type = "l",ylim = c(0.1,10),xlim = c(0.1,10),log = "xy")#
lines(aC,aD_C)#
#
bD = 0.1#
bC = 0.1#
aD_D = 2*e + sC - bD*(1-e/aC)#
aD_C = bC*e/(aC - 2*e - sC + bC)#
lines(aC,aD_C,col = "darkred")#
lines(aC,aD_D,col = "darkred")
abline(v = 2*e+sD)
abline(h = 0.1)
plot(aC,aD_D,type = "l",ylim = c(0.01,10),xlim = c(0.01,10),log = "xy")#
lines(aC,aD_C)#
abline(h = e)#
abline(v = e)#
abline(v = 2*e + sD,col = "darkred")#
abline(h = 2*e+sC,col = "darkred")
plot(aC,aD_D,type = "l",ylim = c(0.01,10),xlim = c(0.01,10),log = "xy")#
lines(aC,aD_C)#
abline(h = e,lty = 3)#
abline(v = e, lty = 3)#
abline(v = 2*e + sD,col = "darkred")#
abline(h = 2*e+sC,col = "darkred")
quartz(height = 5, width = 6)#
par(mar = c(5,6,1,1))#
plot(aC,aD_D,type = "l",ylim = c(0.01,10),xlim = c(0.01,10),log = "xy")#
lines(aC,aD_C)#
abline(h = e,lty = 3)#
abline(v = e, lty = 3)#
abline(v = 2*e + sD,col = "darkred")#
abline(h = 2*e+sC,col = "darkred")
quartz(height = 5, width = 6)#
par(mar = c(5,6,1,1))#
plot(aC,aD_D,type = "l",ylim = c(0.05,10),xlim = c(0.05,10),log = "xy")#
lines(aC,aD_C)#
abline(h = e,lty = 3)#
abline(v = e, lty = 3)#
abline(v = 2*e + sD,col = "darkred")#
abline(h = 2*e+sC,col = "darkred")
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")
source("SDM.R")
source("transition_model.R")
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")
source("transition_model.R")
source("fit_model.R")
# Source packages#
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")#
source("anneal_custom.R")#
source("likeli.R")#
source("analyze_function.R")#
source("likdisplay.R")
var = list()#
var$t0 = "t0"#
var$t1 = "t1"#
var$ENV = "ENV"#
var$lik = "predicted"#
var$EC = "EC"#
var$ED = "ED"#
var$EM = "EM"#
setwd("/Users/DGravel/Desktop/transition_maple/analyses/data")#
data = as.data.frame(read.table("data_categorical.txt"))#
test = numeric(nrow(data))#
test[data$t0 == "D" & data$t1 == "C"] = 1#
test[data$t0 == "C" & data$t1 == "D"] = 1#
pred = read.table("data_pred_states.txt")#
data = subset(data, test!=1)#
pred = subset(pred, test!=1)#
data$ENV = data$av_annual_mean_tp#
data$EC = pred[,1]#
data$ED = pred[,2]#
data$EM = pred[,3] #
#
# Evaluate initial parameter values#
transitions = paste(data$t0,data$t1,sep = "")#
sum_transitions = table(transitions)#
tot_transitions = table(data$t0)
eps_mn = (sum_transitions[3]+sum_transitions[9])/2/length(transitions)#
#
thetac_mn = sum_transitions[6]/tot_transitions[3]#
thetad_mn = sum_transitions[7]/tot_transitions[2]#
#
betac_mn = sum_transitions[7]*(tot_transitions[1]+tot_transitions[3])/tot_transitions[3]/sum(tot_transitions)#
betad_mn = sum_transitions[7]*(tot_transitions[3]+tot_transitions[3])/tot_transitions[3]/sum(tot_transitions)#
#
phic_mn = sum_transitions[10]/tot_transitions[4]#
phid_mn = sum_transitions[11]/tot_transitions[4]#
#
logit_eps_mn = log(eps_mn/(1-eps_mn))#
#
logit_thetac_mn = log(thetac_mn/(1-thetac_mn))#
logit_thetad_mn = log(thetad_mn/(1-thetad_mn))#
logit_betac_mn = log(betac_mn/(1-betac_mn))#
logit_betad_mn = log(betad_mn/(1-betad_mn))#
#
# List initial parameters#
par = list(ac0 =-5,#
ac1 = 0,#
ac2 = 0, #
ad0 = -5,#
ad1 = 0,#
ad2 = 0,#
bc0 = logit_betac_mn,#
bc1 = 0,#
bc2 = 0,#
bd0 = logit_betad_mn,#
bd1 = 0,#
bd2 = 0,#
td0 = logit_thetad_mn,#
td1 = 0,#
td2 = 0,#
tc0 = logit_thetac_mn,#
tc1 = 0,#
tc2 = 0,#
e0c = logit_eps_mn,#
e1c = 0,#
e2c = 0,#
e0d = logit_eps_mn,#
e1d = 0,#
e2d = 0,#
e0m = logit_eps_mn,#
e1m = 0,#
e2m = 0)#
#
par_lo = list(ac0 = -10,#
ac1 = -20,#
ac2 = -20, #
ad0 = -10,#
ad1 = -10,#
ad2 = -20,#
bc0 = -10,#
bc1 = -10,#
bc2 = -25,#
bd0 = -30,#
bd1 = -10,#
bd2 = -10,#
td0 = -10,#
td1 = -10,#
td2 = -25,#
tc0 = -10,#
tc1 = -10,#
tc2 = -20,#
e0c = -10,#
e1c = -10,#
e2c = -10,#
e0d = -10,#
e1d = -10,#
e2d = -10,#
e0m = -10,#
e1m = -10,#
e2m = -10)#
#
par_hi = list(ac0 = 50,#
ac1 = 15,#
ac2 = 30, #
ad0 = 10,#
ad1 = 10,#
ad2 = 10,#
bc0 = 10,#
bc1 = 10,#
bc2 = 20,#
bd0 = 10,#
bd1 = 10,#
bd2 = 50,#
td0 = 10,#
td1 = 10,#
td2 = 20,#
tc0 = 10,#
tc1 = 10,#
tc2 = 20,#
e0c = 10,#
e1c = 10,#
e2c = 10,#
e0d = 10,#
e1d = 10,#
e2d = 10,#
e0m = 10,#
e1m = 10,#
e2m = 10)
source("transition_model.R")
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")
source("transition_model.R")
source("fit_model.R")
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")
source("transition_model.R")
source("fit_model.R")
model()
model
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")
source("transition_model.R")
source("fit_model.R")
lik = numeric(length(t0))#
#
	# Compute the logit#
	logit_alphac 	= ac0 + ac1*ENV + ac2*ENV^2#
	logit_alphad 	= ad0 + ad1*ENV + ad2*ENV^2#
	logit_betac 	= bc0 + bc1*ENV + bc2*ENV^2#
	logit_betad 	= bd0 + bd1*ENV + bd2*ENV^2#
	logit_thetac	= tc0 + tc1*ENV + tc2*ENV^2#
	logit_thetad	= td0 + td1*ENV + td2*ENV^2#
	logit_epsd 	= e0d  + e1d*ENV  + e2d*ENV^2#
	logit_epsc 	= e0c  + e1c*ENV  + e2c*ENV^2#
	logit_epsm 	= e0m  + e1m*ENV  + e2m*ENV^2#
#
	# Back transform into probabilities#
	alphac = exp(logit_alphac)/(1+exp(logit_alphac))#
	alphad = exp(logit_alphad)/(1+exp(logit_alphad))#
	betac = exp(logit_betac)/(1+exp(logit_betac))*(EC+EM)#
	betad = exp(logit_betad)/(1+exp(logit_betad))*(ED+EM)#
	thetac = exp(logit_thetac)/(1+exp(logit_thetac))#
	thetad = exp(logit_thetad)/(1+exp(logit_thetad))#
	epsd = exp(logit_epsd)/(1+exp(logit_epsd))#
	epsc = exp(logit_epsc)/(1+exp(logit_epsc))#
	epsm = exp(logit_epsm)/(1+exp(logit_epsm))	#
	phic = alphac*(EM + EC)*(1-alphad*(ED+EM))#
	phid = alphad*(EM + ED)*(1-alphad*(EC+EM))#
	phim = phic*phim#
	# Compute the likelihood of observations#
	lik[t0 == "C" & t1 == "M"] = betad[t0 == "C" & t1 == "M"] #
	lik[t0 == "C" & t1 == "T"] = epsc[t0 == "C" & t1 == "T"] 	#
	lik[t0 == "C" & t1 == "C"] = (1 - epsc - betad)[t0 == "C" & t1 == "C"]#
#
	lik[t0 == "D" & t1 == "D"] = (1 - epsd - betac)[t0 == "D" & t1 == "D"] 	#
	lik[t0 == "D" & t1 == "M"] = betac[t0 == "D" & t1 == "M"] 			#
	lik[t0 == "D" & t1 == "T"] = epsd[t0 == "D" & t1 == "T"] 		#
	lik[t0 == "M" & t1 == "C"] = thetac[t0 == "M" & t1 == "C"]	#
	lik[t0 == "M" & t1 == "D"] = thetad[t0 == "M" & t1 == "D"] 	#
	lik[t0 == "M" & t1 == "M"] = (1 - epsm - thetac - thetad)[t0 == "M" & t1 == "M"] 			#
	lik[t0 == "M" & t1 == "T"] = epsm[t0 == "M" & t1 == "T"] #
	lik[t0 == "T" & t1 == "C"] = phic[t0 == "T" & t1 == "C"] 	#
	lik[t0 == "T" & t1 == "D"] = phid[t0 == "T" & t1 == "D"]	#
	lik[t0 == "T" & t1 == "M"] = phim[t0 == "T" & t1 == "M"] 			#
	lik[t0 == "T" & t1 == "T"] = (1 - phic - phid - phim)[t0 == "T" & t1 == "T"] #
#
	lik[lik==0] = NA
attach(par)
lik = numeric(length(t0))#
#
	# Compute the logit#
	logit_alphac 	= ac0 + ac1*ENV + ac2*ENV^2#
	logit_alphad 	= ad0 + ad1*ENV + ad2*ENV^2#
	logit_betac 	= bc0 + bc1*ENV + bc2*ENV^2#
	logit_betad 	= bd0 + bd1*ENV + bd2*ENV^2#
	logit_thetac	= tc0 + tc1*ENV + tc2*ENV^2#
	logit_thetad	= td0 + td1*ENV + td2*ENV^2#
	logit_epsd 	= e0d  + e1d*ENV  + e2d*ENV^2#
	logit_epsc 	= e0c  + e1c*ENV  + e2c*ENV^2#
	logit_epsm 	= e0m  + e1m*ENV  + e2m*ENV^2#
#
	# Back transform into probabilities#
	alphac = exp(logit_alphac)/(1+exp(logit_alphac))#
	alphad = exp(logit_alphad)/(1+exp(logit_alphad))#
	betac = exp(logit_betac)/(1+exp(logit_betac))*(EC+EM)#
	betad = exp(logit_betad)/(1+exp(logit_betad))*(ED+EM)#
	thetac = exp(logit_thetac)/(1+exp(logit_thetac))#
	thetad = exp(logit_thetad)/(1+exp(logit_thetad))#
	epsd = exp(logit_epsd)/(1+exp(logit_epsd))#
	epsc = exp(logit_epsc)/(1+exp(logit_epsc))#
	epsm = exp(logit_epsm)/(1+exp(logit_epsm))	#
	phic = alphac*(EM + EC)*(1-alphad*(ED+EM))#
	phid = alphad*(EM + ED)*(1-alphad*(EC+EM))#
	phim = phic*phim
attach(var)
ENV
ENV = data$ENV
lik = numeric(length(t0))#
#
	# Compute the logit#
	logit_alphac 	= ac0 + ac1*ENV + ac2*ENV^2#
	logit_alphad 	= ad0 + ad1*ENV + ad2*ENV^2#
	logit_betac 	= bc0 + bc1*ENV + bc2*ENV^2#
	logit_betad 	= bd0 + bd1*ENV + bd2*ENV^2#
	logit_thetac	= tc0 + tc1*ENV + tc2*ENV^2#
	logit_thetad	= td0 + td1*ENV + td2*ENV^2#
	logit_epsd 	= e0d  + e1d*ENV  + e2d*ENV^2#
	logit_epsc 	= e0c  + e1c*ENV  + e2c*ENV^2#
	logit_epsm 	= e0m  + e1m*ENV  + e2m*ENV^2#
#
	# Back transform into probabilities#
	alphac = exp(logit_alphac)/(1+exp(logit_alphac))#
	alphad = exp(logit_alphad)/(1+exp(logit_alphad))#
	betac = exp(logit_betac)/(1+exp(logit_betac))*(EC+EM)#
	betad = exp(logit_betad)/(1+exp(logit_betad))*(ED+EM)#
	thetac = exp(logit_thetac)/(1+exp(logit_thetac))#
	thetad = exp(logit_thetad)/(1+exp(logit_thetad))#
	epsd = exp(logit_epsd)/(1+exp(logit_epsd))#
	epsc = exp(logit_epsc)/(1+exp(logit_epsc))#
	epsm = exp(logit_epsm)/(1+exp(logit_epsm))	#
	phic = alphac*(EM + EC)*(1-alphad*(ED+EM))#
	phid = alphad*(EM + ED)*(1-alphad*(EC+EM))#
	phim = phic*phim
names(pred)
EC = pred$C
ED = pred$D
EM = pred$M
lik = numeric(length(t0))#
#
	# Compute the logit#
	logit_alphac 	= ac0 + ac1*ENV + ac2*ENV^2#
	logit_alphad 	= ad0 + ad1*ENV + ad2*ENV^2#
	logit_betac 	= bc0 + bc1*ENV + bc2*ENV^2#
	logit_betad 	= bd0 + bd1*ENV + bd2*ENV^2#
	logit_thetac	= tc0 + tc1*ENV + tc2*ENV^2#
	logit_thetad	= td0 + td1*ENV + td2*ENV^2#
	logit_epsd 	= e0d  + e1d*ENV  + e2d*ENV^2#
	logit_epsc 	= e0c  + e1c*ENV  + e2c*ENV^2#
	logit_epsm 	= e0m  + e1m*ENV  + e2m*ENV^2#
#
	# Back transform into probabilities#
	alphac = exp(logit_alphac)/(1+exp(logit_alphac))#
	alphad = exp(logit_alphad)/(1+exp(logit_alphad))#
	betac = exp(logit_betac)/(1+exp(logit_betac))*(EC+EM)#
	betad = exp(logit_betad)/(1+exp(logit_betad))*(ED+EM)#
	thetac = exp(logit_thetac)/(1+exp(logit_thetac))#
	thetad = exp(logit_thetad)/(1+exp(logit_thetad))#
	epsd = exp(logit_epsd)/(1+exp(logit_epsd))#
	epsc = exp(logit_epsc)/(1+exp(logit_epsc))#
	epsm = exp(logit_epsm)/(1+exp(logit_epsm))	#
	phic = alphac*(EM + EC)*(1-alphad*(ED+EM))#
	phid = alphad*(EM + ED)*(1-alphad*(EC+EM))#
	phim = phic*phim
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")
source("fit_model.R")
source("transition_model.R")
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")
source("transition_model.R")
source("fit_model.R")
setwd("/Users/DGravel/Desktop/transition_maple/analyses/data")#
attach(read.table("par.txt"))#
par  = read.table("par.txt")#
#
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")#
source("get_transitions.R")#
#
# Compute equilibrium for two initial conditions#
Tgrad = seq(-1,5,0.05)#
reslow = matrix(nr = length(Tgrad), nc = 4)#
reshigh = matrix(nr = length(Tgrad), nc = 4)#
#
res_M = matrix(nr = length(Tgrad), nc = 4)#
#
for(j in 1:length(Tgrad)) {#
#
	p0 = get_eq(p = c(1,0.0,0,0),ENV = Tgrad[j],par)#
	p0[2] = 0.001#
	p0[1] = p0[1]-0.001#
	reslow[j,] 	= get_eq(p = p0,ENV = Tgrad[j],par)#
	p0 = get_eq(p = c(0,1,0,0),ENV = Tgrad[j],par)#
	p0[1] = 0.001#
	p0[2] = p0[1]-0.001#
	reshigh[j,] = get_eq(p = p0,ENV = Tgrad[j],par)#
	res_M[j,] = get_eq(p = c(0,1,0,0),ENV = Tgrad[j],par)#
#
}#
#
# Plot the results#
quartz(height = 6, width = 8)#
par(mar=c(5,5,2,1))#
plot(Tgrad,reslow[,1],type ="l",ylim=c(0,1),cex.axis = 1.25, cex.lab = 1.25, xlab = "Température moyenne annuelle", ylab = "Proportion du paysage",lwd = 2,)#
lines(Tgrad,reslow[,2],col="darkred",lwd = 2)#
lines(Tgrad,reslow[,3],col ="darkblue",lwd = 2)#
lines(Tgrad,reslow[,4],col = "darkgreen",lwd = 2)#
#
lines(Tgrad,reshigh[,1],col="black",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,2],col="darkred",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,3],col ="darkblue",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,4],col = "darkgreen",lty = 3,lwd = 2)#
#
legend("top",bty = "n", col = c("black","darkred","darkblue","darkgreen"),legend = c("C","D","M","T"),lty = 1,horiz=TRUE,lwd=3)#
#
setwd("/Users/DGravel/Desktop/transition_maple/analyses/figures")#
dev.copy2pdf(file = "SDMeq.pdf")
# optimisation#
# prerun the model with glm to find some parameter values that are not jointly constrained#
# use logits#
#
#######################################################
get_transitions = function(t0,EC,ED,EM,ENV,par) #
{#
with(par, {#
	p = numeric(4)#
#
	# Compute the logit#
	logit_alphac 	= ac0 + ac1*ENV + ac2*ENV^2#
	logit_alphad 	= ad0 + ad1*ENV + ad2*ENV^2#
	logit_betac 	= bc0 + bc1*ENV + bc2*ENV^2#
	logit_betad 	= bd0 + bd1*ENV + bd2*ENV^2#
	logit_thetac	= tc0 + tc1*ENV + tc2*ENV^2#
	logit_thetad	= td0 + td1*ENV + td2*ENV^2#
	logit_epsd 	= e0d  + e1d*ENV  + e2d*ENV^2#
	logit_epsc 	= e0c  + e1c*ENV  + e2c*ENV^2#
	logit_epsm 	= e0m  + e1m*ENV  + e2m*ENV^2#
#
	# Back transform into probabilities#
	alphac = exp(logit_alphac)/(1+exp(logit_alphac))#
	alphad = exp(logit_alphad)/(1+exp(logit_alphad))#
	betac = exp(logit_betac)/(1+exp(logit_betac))*(EC+EM)#
	betad = exp(logit_betad)/(1+exp(logit_betad))*(ED+EM)#
	thetac = exp(logit_thetac)/(1+exp(logit_thetac))#
	thetad = exp(logit_thetad)/(1+exp(logit_thetad))#
	epsd = exp(logit_epsd)/(1+exp(logit_epsd))#
	epsc = exp(logit_epsc)/(1+exp(logit_epsc))#
	epsm = exp(logit_epsm)/(1+exp(logit_epsm))		#
#
	phic = alphac*(EM + EC)*(1-alphad*(ED+EM))#
	phid = alphad*(EM + ED)*(1-alphad*(EC+EM))#
	phim = phic*phid#
	if(t0 == "C") { #
		p[1] = (1 - epsc - betad)#
		p[2] = 0#
		p[3] = betad#
		p[4] = epsc#
	}#
	else if(t0 == "D") { #
		p[1] = 0#
		p[2] = (1 - epsd - betac)#
		p[3] = betac	#
		p[4] = epsd#
	}	#
#
	else if(t0 == "M") { #
		p[1] = thetac#
		p[2] = thetad#
		p[3] = 1 - thetac - thetad - epsm#
		p[4] = epsm#
	}	#
#
	else if(t0 == "T") { #
		p[1] = phic#
		p[2] = phid#
		p[3] = phim#
		p[4] = 1-phic-phid-phim#
	}			#
	p#
	})#
}#
#
#######################################################
get_transitions_landscape = function(x) get_transitions(t0=x[1],EC=as.numeric(x[2]),ED=as.numeric(x[3]),EM=as.numeric(x[4]),ENV=as.numeric(x[5]),par)#
#
#######################################################
get_matrix = function(EC,ED,EM,ENV,par) {#
	mat = matrix(nr = 4, nc = 4)#
	mat[1,] = get_transitions(t0="C",EC,ED,EM,ENV,par)#
	mat[2,] = get_transitions(t0="D",EC,ED,EM,ENV,par)#
	mat[3,] = get_transitions(t0="M",EC,ED,EM,ENV,par)#
	mat[4,] = get_transitions(t0="T",EC,ED,EM,ENV,par)			#
	return(mat)#
}#
#
#######################################################
get_eq = function(p,ENV,par) {#
	for(i in 1:1000) {#
		mat = get_matrix(EC = p[1],ED = p[2],EM = p[3],ENV,par)#
		p = p%*%mat#
			}	#
	return(p)#
}
setwd("/Users/DGravel/Desktop/transition_maple/analyses/data")#
attach(read.table("par.txt"))#
par  = read.table("par.txt")#
#
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")#
source("get_transitions.R")#
#
# Compute equilibrium for two initial conditions#
Tgrad = seq(-1,5,0.05)#
reslow = matrix(nr = length(Tgrad), nc = 4)#
reshigh = matrix(nr = length(Tgrad), nc = 4)#
#
res_M = matrix(nr = length(Tgrad), nc = 4)#
#
for(j in 1:length(Tgrad)) {#
#
	p0 = get_eq(p = c(1,0.0,0,0),ENV = Tgrad[j],par)#
	p0[2] = 0.001#
	p0[1] = p0[1]-0.001#
	reslow[j,] 	= get_eq(p = p0,ENV = Tgrad[j],par)#
	p0 = get_eq(p = c(0,1,0,0),ENV = Tgrad[j],par)#
	p0[1] = 0.001#
	p0[2] = p0[1]-0.001#
	reshigh[j,] = get_eq(p = p0,ENV = Tgrad[j],par)#
	res_M[j,] = get_eq(p = c(0,1,0,0),ENV = Tgrad[j],par)#
#
}#
#
# Plot the results#
quartz(height = 6, width = 8)#
par(mar=c(5,5,2,1))#
plot(Tgrad,reslow[,1],type ="l",ylim=c(0,1),cex.axis = 1.25, cex.lab = 1.25, xlab = "Température moyenne annuelle", ylab = "Proportion du paysage",lwd = 2,)#
lines(Tgrad,reslow[,2],col="darkred",lwd = 2)#
lines(Tgrad,reslow[,3],col ="darkblue",lwd = 2)#
lines(Tgrad,reslow[,4],col = "darkgreen",lwd = 2)#
#
lines(Tgrad,reshigh[,1],col="black",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,2],col="darkred",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,3],col ="darkblue",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,4],col = "darkgreen",lty = 3,lwd = 2)#
#
legend("top",bty = "n", col = c("black","darkred","darkblue","darkgreen"),legend = c("C","D","M","T"),lty = 1,horiz=TRUE,lwd=3)#
#
setwd("/Users/DGravel/Desktop/transition_maple/analyses/figures")#
dev.copy2pdf(file = "SDMeq.pdf")
N = numeric(100)#
N[1] = 1#
#
r = 1#
K = 100#
for(i in 2:100) #
	N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)#
Time = c(1:100)#
plot(Time,N,type = "l")
r = 2#
K = 100#
dT = 1#
for(i in 2:100) #
	N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)*dT#
Time = c(1:100)#
plot(Time,N,type = "l")
r = 2.5#
K = 100#
dT = 1#
for(i in 2:100) #
	N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)*dT#
Time = c(1:100)#
plot(Time,N,type = "l")
r = 2.5#
K = 100#
dT = .1#
for(i in 2:100) #
	N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)*dT#
Time = c(1:100)#
plot(Time,N,type = "l")
r = 4#
K = 100#
dT = 1#
for(i in 2:100) #
	N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)*dT#
Time = c(1:100)#
plot(Time,N,type = "l")
r = 3.5#
K = 100#
dT = 1#
for(i in 2:100) #
	N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)*dT#
Time = c(1:100)#
plot(Time,N,type = "l")
r = 3.#
K = 100#
dT = 1#
for(i in 2:100) #
	N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)*dT#
Time = c(1:100)#
plot(Time,N,type = "l")
N = numeric(100)#
N[1] = 1.1#
#
r = 3.#
K = 100#
dT = 1#
for(i in 2:100) #
	N[i] = N[i-1] + r*N[i-1]*(1-N[i-1]/K)*dT
lines(Time,N,col = "red")
# Load the library#
library(deSolve)#
#
# Define the mathematical model#
model = function(Time, State, Pars) {#
	with(as.list(c(State,Pars)), {#
		dR = r*R*(1-R/K) - a*R*C/(1+b*R)#
		dC = a*R*C/(1+b*R) - d*C#
		list(c(dR,dC))#
	})#
}#
#
# Define the parameters#
r = 1#
a = 1#
b = 5#
d = 0.1#
K = 0.6#
#
# Collect them in a vector#
pars = c(r = r, a = a, b = b, d = d, K = K)#
#
# Set the initial conditions#
T0 = c(R = 1, C = 0.1)#
#
# Set the conditions for the simulation#
times = seq(0, 1000, by = 0.1) #
#
# Run the simulation#
out = ode(func=model, y = T0, parms = pars, times = times)
# Plot the results#
par(mar = c(5,6,2,1))#
plot(out[,1],out[,2],type="l",xlab = "Time",ylab = "Density",cex.lab = 1.75, #
cex.axis = 1.5,ylim=range(out[,2:3]))  #
lines(out[,1],out[,3],col = "blue")
?ode
library(rootSolve)#
#
# Specify the model#
model = function(t,y,pars) {#
with(as.list(c(y,pars)), {#
	dR = r*R*(1-R/K) - a*R*C/(1+b*R)#
	dC = a*R*C/(1+b*R) - d*C 		#
	list(c(dR,dC))#
	})#
}#
#
# Parameters#
pars = c(r = 1, K = 0.7, a = 1, b = 5, d = 0.1)	#
#
# Initial conditions#
T0 = c(R = 0.1, C = 1.1)#
# Solve the model using stode (iterative state solver)#
eq = stode(y=T0, func=model, parms=pars, pos=TRUE)[[1]]#
#
# Compute the jacobian#
J = jacobian.full(y=eq,func=model,parms=pars)
eq
eigen(J)$values
# Vecteur of K values#
Ks = seq(0.5,1,0.01)#
#
# Vector to store the results#
res = numeric(length(Ks))#
#
# Loop to calculate eigen values for each K value#
for(i in 1:length(Ks)) {	#
	pars = c(r = 1, K = Ks[i], a = 1, b = 5, d = 0.1)#
	eq = stode(y=eq, func=model, parms=pars, pos=TRUE)[[1]]#
	J = jacobian.full(y=eq,func=model,parms=pars)#
	res[i] = max(as.numeric(eigen(J)$values))#
}
warnings()
res
# Plot the results#
par(mar = c(5,6,2,1))#
plot(Ks,res, type = "l", xlab = "K", ylab = "Maximal eigen value", cex.axis = 1.25, cex.lab = 1.5)#
abline(h = 0, lty = 3)#
#
# Analytical criteria#
a = 1#
b = 5#
d = 0.1#
abline(v = (1+d*b)/(a*b*(1-d*b)), lty = 3, col = "red")
setwd("/Users/DGravel/Desktop/transition_maple/analyses/data")#
attach(read.table("par.txt"))#
par  = read.table("par.txt")#
#
setwd("/Users/DGravel/Desktop/transition_maple/analyses/scripts")#
source("get_transitions.R")#
#
# Compute equilibrium for two initial conditions#
Tgrad = seq(-1,5,0.05)#
reslow = matrix(nr = length(Tgrad), nc = 4)#
reshigh = matrix(nr = length(Tgrad), nc = 4)#
#
res_M = matrix(nr = length(Tgrad), nc = 4)#
#
for(j in 1:length(Tgrad)) {#
#
	p0 = get_eq(p = c(1,0.0,0,0),ENV = Tgrad[j],par)#
	p0[2] = 0.001#
	p0[1] = p0[1]-0.001#
	reslow[j,] 	= get_eq(p = p0,ENV = Tgrad[j],par)#
	p0 = get_eq(p = c(0,1,0,0),ENV = Tgrad[j],par)#
	p0[1] = 0.001#
	p0[2] = p0[1]-0.001#
	reshigh[j,] = get_eq(p = p0,ENV = Tgrad[j],par)#
	res_M[j,] = get_eq(p = c(0,1,0,0),ENV = Tgrad[j],par)#
#
}#
#
# Plot the results#
quartz(height = 6, width = 8)#
par(mar=c(5,5,2,1))#
plot(Tgrad,reslow[,1],type ="l",ylim=c(0,1),cex.axis = 1.25, cex.lab = 1.25, xlab = "Température moyenne annuelle", ylab = "Proportion du paysage",lwd = 2,)#
lines(Tgrad,reslow[,2],col="darkred",lwd = 2)#
lines(Tgrad,reslow[,3],col ="darkblue",lwd = 2)#
lines(Tgrad,reslow[,4],col = "darkgreen",lwd = 2)#
#
lines(Tgrad,reshigh[,1],col="black",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,2],col="darkred",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,3],col ="darkblue",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,4],col = "darkgreen",lty = 3,lwd = 2)#
#
legend("top",bty = "n", col = c("black","darkred","darkblue","darkgreen"),legend = c("C","D","M","T"),lty = 1,horiz=TRUE,lwd=3)#
#
setwd("/Users/DGravel/Desktop/transition_maple/analyses/figures")#
dev.copy2pdf(file = "SDMeq.pdf")
plot(Tgrad,res_M,[,2],type = "l")
plot(Tgrad,res_M[,2],type = "l")
plot(Tgrad,res_M[,3],type = "l")
plot(Tgrad,res_M[,4],type = "l")
plot(Tgrad,reslow[,1],type ="l",ylim=c(0,1),cex.axis = 1.25, cex.lab = 1.25, xlab = "Température moyenne annuelle", ylab = "Proportion du paysage",lwd = 2,)
lines(Tgrad,reslow[,2],col="darkred",lwd = 2)
lines(Tgrad,reslow[,3],col ="darkblue",lwd = 2)
lines(Tgrad,reslow[,4],col = "darkgreen",lwd = 2)
lines(Tgrad,reshigh[,1],col="black",lty = 3,lwd = 2)
lines(Tgrad,reshigh[,2],col="darkred",lty = 3,lwd = 2)
lines(Tgrad,reshigh[,3],col ="darkblue",lty = 3,lwd = 2)
lines(Tgrad,reshigh[,4],col = "darkgreen",lty = 3,lwd = 2)
plot(Tgrad,reslow[,1],type ="l",ylim=c(0,1),cex.axis = 1.25, cex.lab = 1.25, xlab = "Température moyenne annuelle", ylab = "Proportion du paysage",lwd = 2,)
lines(Tgrad,reshigh[,1],col="black",lty = 3,lwd = 2)
lines(Tgrad,reshigh[,2],col="darkred",lty = 3,lwd = 2)
lines(Tgrad,reshigh[,3],col ="darkblue",lty = 3,lwd = 2)
lines(Tgrad,reshigh[,4],col = "darkgreen",lty = 3,lwd = 2)
plot(Tgrad,reslow[,1],type ="l",ylim=c(0,1),cex.axis = 1.25, cex.lab = 1.25, xlab = "Température moyenne annuelle", ylab = "Proportion du paysage",lwd = 2,)#
lines(Tgrad,reslow[,2],col="darkred",lwd = 2)#
lines(Tgrad,reslow[,3],col ="darkblue",lwd = 2)#
lines(Tgrad,reslow[,4],col = "darkgreen",lwd = 2)#
#
lines(Tgrad,reshigh[,1],col="black",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,2],col="darkred",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,3],col ="darkblue",lty = 3,lwd = 2)#
lines(Tgrad,reshigh[,4],col = "darkgreen",lty = 3,lwd = 2)#
#
legend("top",bty = "n", col = c("black","darkred","darkblue","darkgreen"),legend = c("C","D","M","T"),lty = 1,horiz=TRUE,lwd=3)
test = c("a","a","b","b","c","c")
model.matrix(test)
